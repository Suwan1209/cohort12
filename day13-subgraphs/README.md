# 오늘의 서기: 홍자영
# {{day13-subgraphs}}

## 오늘의 핵심
- 복잡도 관리와 멀티 에이전트: 단일 그래프의 **컨텍스트 폭발(Context Explosion)**과 노이즈를 방지하기 위해, 기능을 독립된 서브그래프(모듈)로 분리하여 효율적인 멀티 에이전트 시스템을 구축한다.
- 연결 방식의 유연성 (Connection Patterns): 부모-자식 간의 State를 공유하는 add_node 방식과, 독립적으로 관리하며 입출력을 변환하는 invoke 방식을 상황에 맞게 선택하여 연결한다.
- 서브그래프의 수명 (Lifecycle & Visibility): 서브그래프의 내부 상태(Snapshot)는 인터럽트(Interrupt)로 멈춰있는 동안에만 조회 가능하며, 실행이 종료되면 태스크가 소멸됨을 이해한다.

## 회고 모음
- {{윤지연}}: Subgraph 연결 방식은 설계 취향이 아니라, 상태를 공유하는 workflow인지 독립 계산 task인지에 따라 구조적으로 결정된다.
- {{양승준}}: invoke a graph from a node는 부모와 자식의 값이 격리되어있다,add a graph as a node 는 변수가 같은 값만 연결되어있고 다른 값은 서브그래프 내부에서만 사용한다
- {{임은상}}: 멀티에이전트에서 로직을 재사용하려고, 서브그래프를 노드 안에서 직접 invoke하거나 노드로 꽂아 실행하고, interrupt로 멈춘 동안에만 서브그래프 내부 상태를 조회·resume할 수 있다.
- {{홍자영}}: subgraph를 invoke manually(함수 안에서 호출)나 add as a node(노드로 추가)의 2가지 방식으로 사용해서 메인 그래프의 평화를 얻을 수 있다!
- {{임정수}}: 서브 그래프에 저희 프로젝트에 추가할 부분을 넣어볼 수 있을지 확인해봤습니다.
- {{곽수영}}: 서브그래프 Invoke 방식 (명시적) 과 Add Node 방식 (구조적)

## 자주 나온 질문
- Q. invoke 하는 형태랑 node로 연결하는 형태를 각각 언제 쓰면 좋을지?
  A. 게임/에이전트/대화 = add_node, 계산기/툴/미니태스크 = invoke
- Q. 서브그래프는 그래프들에게 분업을 시키는 관점에서 존재하는지 아니면 context 관리를 깔끔하게 하기 위함인지?
  A. 둘 다!
